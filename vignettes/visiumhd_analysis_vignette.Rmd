---
title: "Analysis, visualization, and integration of Visium HD spatial datasets with Seurat"
output:
  html_document:
    theme: united
    df_print: kable
  pdf_document: default
date: 'Compiled: `r Sys.Date()`'
---

```{r setup, include=FALSE}
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  time_it = TRUE,
  error = TRUE
)
```

# Visium HD support in Seurat

We have [previously released support](https://satijalab.org/seurat/articles/spatial_vignette) Seurat for sequencing-based spatial transcriptomic (ST) technologies, including 10x visium and SLIDE-seq. We have now updated Seurat to be compatible with the Visium HD technology, which performs profiling at substantially higher spatial resolution than previous versions.

Users can install the Visium HD-compatible release from Github. Existing Seurat workflows for [clustering, visualization, and downstream analysis](https://satijalab.org/seurat/articles/pbmc3k_tutorial) have been updated to support both Visium and Visium HD data.

We note that Visium HD data is generated from spatially patterned olignocleotides labeled in 2um x 2um bins. However, since the data from this resolution is sparse, adjacent bins are pooled together to create 8um and 16um resolutions. 10x recommends the use of 8um binned data for analysis, but Seurat supports in the simultaneous loading of multiple binnings - and stores them in a single object as multiple assays.

In this vignette, we provide an overview of some of the spatial workflows that Seurat supports for analyzing Visium HD data, in particular:

* Unsupervised clustering
* Identification of spatial tissue domains
* Subsetting spatial regions
* Integration with scRNA-seq data
* Comparing the spatial localization of different cell types

Please note that Visium HD is a new data type, and we expect to update this vignette as we test additional methods for spatial data analysis. We strongly encourage users to explore how different parameter settings affect their results, to analyze data iteratively (and in collaboration with biological experts), and to orthogonally validate unexpected or surprising biological findings.

We focus our analysis on a Visium HD dataset from the mouse brain, available to download [here](https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-of-mouse-brain-he) but also run clustering workflow on a dataset from the mouse intestine. 

## Install Seurat Update
```{r, eval=FALSE}
# packages required for Visium HD
install.packages("hdf5r")
install.packages("arrow")

# Install version v5.0.4
remotes::install_github(repo = "satijalab/seurat", ref = "visium-hd")
```

```{r install, eval = FALSE}
library(Seurat)
library(SeuratData)
library(ggplot2)
library(patchwork)
library(dplyr)
```

## Load Visium HD data

* Visium HD mouse brain dataset is available for download [here](https://support.10xgenomics.com/spatial-gene-expression/datasets)
* The Seurat can store multiple binnings/resolutions in different assays
* `bin.size` parameter specifies resolutions to load (8 and 16um are loaded by default)
* Users can switch between resolutions by [changing the assay](https://satijalab.org/seurat/articles/multimodal_vignette)

```{r data}
localdir <- "/brahms/lis/visium_hd/mouse/new_mousebrain/" 
object <- Load10X_Spatial(data.dir = localdir, bin.size = c(8, 16))

# Setting default assay changes between 8um and 16um binning
Assays(object)
DefaultAssay(object) <- "Spatial.008um"
```
```{r qc, fig.height=5}
vln.plot <- VlnPlot(object, features = 'nCount_Spatial.008um', pt.size = 0) + NoLegend()
count.plot <- SpatialFeaturePlot(object, features = 'nCount_Spatial.008um', pt.size.factor = 1.2) + theme(legend.position = "right")
```
```{r}
# note that many spots have very few counts, in-part 
# due to low cellular density in certain tissue regions
vln.plot | count.plot
```

## Normalize datasets

In this vignette we use standard log-normalization for spatial data. We note that the best normalization methods for spatial data are still being developed and evaluated, and encourage users to read manuscripts from the [Phipson/Davis](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-024-03241-7) and [Fan](https://www.biorxiv.org/content/10.1101/2023.08.30.555624v2) labs to learn more about potential caveats for spatial normalization.

```{r normalize}
# normalize both 8um and 16um bins
DefaultAssay(object) <- "Spatial.008um"
object <- NormalizeData(object)

DefaultAssay(object) <- "Spatial.016um"
object <- NormalizeData(object)
```

## Visualize gene expression 

* Setting `pt.size.factor` to 1.2 helps to visualize molecular and histological info in this HD dataset  
* You can also adjust the `shape`, and `stroke` (outline) parameters for visualization

```{r feature.plots}
# switch spatial resolution to 16um from 8um
DefaultAssay(object) <- "Spatial.016um"
p1 <- SpatialFeaturePlot(object, features = "Rorb", pt.size.factor = 1.2) + ggtitle("Rorb expression (16um)")

# switch back to 8um
p2 <- SpatialFeaturePlot(object, features = "Hpca", pt.size.factor = 1.2) + ggtitle("Hpca expression (8um)")
```
```{r}
p1 | p2
```

## Unsupervised clustering

While the standard scRNA-seq clustering workflow can also be applied to spatial datasets - we have observed that when working with Visium HD datasets, the [Seurat v5 sketch clustering workflow](https://satijalab.org/seurat/articles/seurat5_sketch_analysis) exhibits improved performance, especially for identifying rare and spatially restricted groups.

As described in [Hao et al, Nature Biotechnology 2023](https://www.nature.com/articles/s41587-023-01767-y) and [Hie et al](https://www.sciencedirect.com/science/article/pii/S2405471219301528), sketch-based analyses aim to 'subsample' large datasets in a way that preserves rare populations. Here, we sketch the Visium HD dataset, perform clustering on the subsampled cells, and then project the cluster labels back to the full dataset.

Details of the sketching procedure and workflow are described in [Hao et al, Nature Biotechnology 2023](https://www.nature.com/articles/s41587-023-01767-y) and the [Seurat v5 sketch clustering vignette](https://satijalab.org/seurat/articles/seurat5_sketch_analysis). Since the full Visium HD dataset fits in memory, we do not use any of the on-disk capabilities of Seurat v5 in this vignette.


```{r sketching}
# note that data is already normalized
DefaultAssay(object) <- "Spatial.008um"
object <- FindVariableFeatures(object)

# we select 50,0000 cells and create a new 'sketch' assay
object <- SketchData(
  object = object,
  ncells = 50000,
  method = "LeverageScore",
  sketched.assay = "sketch"
)
```

```{r sketch.preprocess}
# switch analysis to sketched cells
DefaultAssay(object) <- "sketch"

# perform clustering workflow
object <- FindVariableFeatures(object)
object <- ScaleData(object)
object <- RunPCA(object, assay="sketch", reduction.name = "pca.sketch")
object <- FindNeighbors(object, assay="sketch", reduction = "pca.sketch", dims = 1:50)
object <- FindClusters(object, cluster.name="seurat_cluster.sketched", resolution = 3)
object <- RunUMAP(object, reduction = "pca.sketch", reduction.name = "umap.sketch", return.model = T, dims = 1:50)
```

Now we can project the cluster labels, and dimensional reductions (PCA and UMAP) that we learned from the 50,000 sketched cells - to the entire dataset, using the `ProjectData` function. 

In the resulting object, for all cells:
* cluster labels will be stored in `object$seurat_cluster.projected`
* Projected PCA embeddings will be stored in `object[["pca.008um"]]`
* Projected UMAP embeddings will be stored in `object[["umap.sketch"]]`
```{r project}

object <- ProjectData(
  object = object,
  assay = "Spatial.008um",
  full.reduction = "pca.008um",
  sketched.assay = "sketch",
  sketched.reduction = "pca.sketch",
  umap.model = "umap.sketch",
  dims = 1:50,
  refdata = list(seurat_cluster.projected = "seurat_cluster.sketched")
)
```

We can visualize the clustering results for the sketched cells, as well as the projected clustering results for the full dataset"

```{r project.plots}
DefaultAssay(object) <- "sketch"
Idents(object) <- "seurat_cluster.sketched"
p1 <- DimPlot(object, reduction = "umap.sketch", label=T, repel=T)
p1 <- p1 + ggtitle("Sketched clustering (50,000 cells)")

# switch to full dataset
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "seurat_cluster.projected"
p2 <- DimPlot(object, reduction = "umap.sketch", label=T, repel=T)
p2 <- p2 + ggtitle("Projected clustering (full dataset)")
p1 | p2
```

Of course, we can now also visualize the unsupervised clusters based on their spatial location. Note that running `SpatialDimPlot(object, interactive = TRUE)`, also enables interactive visualization and exploration.

```{r cluster.plot}
SpatialDimPlot(object, label=T, repel=T)
```

When there are many different clusters (some of which are spatially restricted and others are mixed), plotting the spatial location of all clusters can be challenging to interpret. We find it helpful to plot the spatial location of different clusters individually. For example, we highlight the spatial localization of a few clusters below, which happen to correspond to different cortical layers:

```{r cluster.plot, fig.height = 10}

plot_cluster_grid <- function(object, ident) {
  Idents(object) <- ident
  num_clusters <- length(levels(object))
  num_cols <- ceiling(sqrt(num_clusters))
  cluster_chunks <- split(levels(object), ceiling(seq_along(levels(object)) / num_cols))
  
  combined_plots <- lapply(cluster_chunks, function(chunk) {
    plot_list <- lapply(chunk, function(ident_level) {
      SpatialDimPlot(object, cells.highlight = WhichCells(object, idents = ident_level), cols.highlight = c("#FFFF00", "grey50")) + NoLegend() + ggtitle(ident_level)
    })
    wrap_plots(plot_list, ncol = length(plot_list)) +
      plot_layout(guides = 'collect') +
      plot_annotation(theme = theme(plot.margin = unit(rep(-0.5, 4), "lines")))
  })
  
  final_plot <- wrap_plots(combined_plots, ncol = 1)
  return(final_plot)
}

p <- plot_cluster_grid(object,ident = "seurat_cluster.projected")
p
```


We can also find and visualize the top gene expression markers for each cluster

```{r heatmap, fig.height = 10}
Idents(object) <- "seurat_cluster.projected"

# Crete downsampled object to make visualization either
object_subset <- subset(object, downsample=1000)

# Order clusters by similarity
object_subset <- BuildClusterTree(object_subset, assay = "Spatial.008um", reduction = "pca.008um", reorder = T)

markers <- FindAllMarkers(object_subset, assay = 'Spatial.008um', only.pos = TRUE)
markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>%
    slice_head(n = 5) %>%
    ungroup() -> top5

p <- DoHeatmap(object_subset, features = top5$gene, group.by = 'seurat_cluster.projected', size = 2.5) + NoLegend()
p
```

## Identifying spatially-defined tissue domains

While the previous analyses consider each bin independently, spatial data enables cells to be defined not just by their neighborhood, but also by their broader spatial context.

In [Singhal et al.](https://www.nature.com/articles/s41588-024-01664-3), the authors introduce BANKSY, Building Aggregates with a Neighborhood Kernel and Spatial Yardstick (BANKSY). BANKSY performs multiple tasks, but we find it particularly valuable for identifying and segmenting tissue domains. When performing clustering, BANKSY augments a spot's expression pattern with both the mean and the gradient of gene expression levels in a spot's broader neighborhood.

We thank the authors for enabling BANKSY to be compatible with Seurat via the [`SeuratWrappers`](https://github.com/satijalab/seurat-wrappers) framework:


```{r banksy}
#remotes::install_github('jleechung/seurat-wrappers&#64;feat-aft')
#remotes::install_github("prabhakarlab/Banksy&#64;devel")
library(SeuratWrappers)
library(Banksy)
```

Before running BANKSY, there are two important model parameters that users should consider:

* `k_geom` : Local neighborhood size. Larger values will yield larger domains
* `lambda` : Influence of the neighborhood. Larger values yield more spatially coherent domains

The `RunBanksy` function creates a new `BANKSY` assay, which can be used for dimensional reduction and clustering:

```{r banksy.run}
object <- RunBanksy(object, lambda = 0.8, verbose=TRUE, 
                      assay = 'Spatial.008um', slot = 'data', features = 'variable',
                      k_geom = 50)
```
```{r banksy.preprocess}
DefaultAssay(object) <- "BANKSY"
object <- RunPCA(object, assay = 'BANKSY', reduction.name = "pca.banksy", features = rownames(object), npcs = 30)
object <- RunUMAP(object, reduction = "pca.banksy", reduction.name = "umap.banksy", dims = 1:30)
object <- FindNeighbors(object, reduction = "pca.banksy", dims = 1:30)
object <- FindClusters(object, cluster.name = "banksy_cluster", resolution = 0.5)
```

```{r banksy.plot}
Idents(object) <- "banksy_cluster"
p <- SpatialDimPlot(object, group.by="banksy_cluster",label=T, repel=T) 
p
```

As with unsupervised clustering, we can highlight the spatial location of each tissue domain individually.

```{r banksy.cluster.plot, fig.height = 10}
p <- plot_cluster_grid(object, ident = "banksy_cluster")
p
```

## Subset out anatomical regions 

Users may wish to segment or subset out a restricted region for further downstream analysis. For example, here we create a coordinate-defined segmentation mask marking cortical and hippocampal regions from the entire dataset using the `CreateSegmentation` function, and then identify cells that fall into this region with the `Overlay` function.

The list of coordinates is available for download [here](INSERT LINK), and users can identify these boundaries when exploring their own datasets using the `interactive=TRUE` argument to `SpatialDimPlot`.

```{r subset1}
cortex.coordinates <- as.data.frame(read.csv('/brahms/lis/visium_hd/final_mouse/cortex-hippocampus_coordinates.csv'))
cortex.coordinates["cell"] <- "cortex"
colnames(cortex.coordinates) <- c("x", "y", "cell")

cortex <- CreateSegmentation(cortex.coordinates)
object[["cortex"]] <- Overlay(object[["slice1.008um"]], cortex)
cortex <- subset(object, cells=Cells(object[['cortex']]))
```

## Integration with scRNA-seq data (deconvolution)

Seurat v5 also includes support for the [Robust Cell Type Decomposition](https://www.nature.com/articles/s41587-021-00830-w), a computational approach to deconvolve spot-level data from spatial datasets, when provided with an scRNA-seq reference. RCTD has been shown to accurately annotate spatial data from a variety of technologies, including SLIDE-seq, Visium, and the 10x Xenium in-situ spatial platform. We observe good performance with Visium HD as well.

To run RCTD, we first install the `spacexr` package from GitHub which implements RCTD.

```{r, eval=FALSE}
devtools::install_github("dmcable/spacexr", build_vignettes = FALSE)
```

RCTD takes an scRNA-seq dataset as a reference, and a spatial dataset as a query. For a reference, we use SKYLAR TO DESCRIBE, available for download [here](). We use the cortex Visium HD object as the spatial query. For computational efficiency, we sketch the spatial query dataset, apply RCTD to deconvolute the 'sketched' cortical cells and annotate them, and then project these annotations to the full cortical dataset.

```{r sketch.cortex}
#sketch the cortical dataset
DefaultAssay(cortex) <- "Spatial.008um"
cortex <- NormalizeData(cortex)
cortex <- FindVariableFeatures(cortex)
cortex <- SketchData(
  object = cortex,
  ncells = 50000,
  method = "LeverageScore",
  sketched.assay = "sketch"
)

DefaultAssay(cortex) <- "sketch"
cortex <- ScaleData(cortex)
cortex <- RunPCA(cortex, assay="sketch", reduction.name = "pca.cortex.sketch", verbose = T)
cortex <- FindNeighbors(cortex, reduction = "pca.cortex.sketch", dims = 1:30)
cortex <- RunUMAP(cortex, reduction = "pca.cortex.sketch", reduction.name = "umap.cortex.sketch", return.model = T, dims = 1:30, verbose = T)
```


```{r sc.data}
# load in the reference scRNA-seq dataset
ref <- readRDS("/brahms/lis/visium_hd/mouse/visiumV2/allen_ref_withsketchumap.rds")
```

```{r rctd.setup, warning=FALSE, results=FALSE}
Idents(ref) <- "subclass_label"

DefaultAssay(ref) <- "sketch"
counts <- ref[["sketch"]]$counts
cluster <- as.factor(ref$subclass_label[Cells(ref[['sketch']])])
names(cluster) <- colnames(ref[['sketch']])

# remove cell types with less than 25 cells
valid_cells <- colnames(counts)[table(cluster)[cluster] >= 25]
filtered_counts <- counts[, valid_cells]

ref$nCount_sketch <- colSums(x = filtered_counts)
nUMI <- ref$nCount_sketch[!is.na(ref$nCount_sketch)]
cluster <- as.factor(cluster[colnames(filtered_counts)])
levels(cluster) <- gsub("/", "-", levels(cluster))
cluster <- droplevels(cluster)

reference <- Reference(counts, cluster, nUMI)

counts_hd <- cortex[["sketch"]]$counts
cortex_cells_hd <- colnames(cortex[["sketch"]])
coords <- GetTissueCoordinates(cortex)
coords <- coords[cortex_cells_hd,]
colnames(coords) <- c("x", "y")
coords[is.na(colnames(coords))] <- NULL

query <- SpatialRNA(coords, counts_hd, colSums(counts_hd))
```

```{r run.rctd, warning=FALSE, results=FALSE, eval=FALSE}
RCTD <- create.RCTD(query, reference, max_cores = 28)
RCTD <- run.RCTD(RCTD, doublet_mode = "doublet")
cortex <- AddMetaData(cortex, metadata = RCTD&#64;results$results_df)
```
```{r project.rctd}
cortex$first_type <- as.character(cortex$first_type)
cortex$first_type[is.na(cortex$first_type)] <- 'Unknown'
cortex <- ProjectData(
  object = cortex,
  assay = "Spatial.008um",
  full.reduction = "pca.cortex",
  sketched.assay = "sketch",
  sketched.reduction = "pca.cortex.sketch",
  umap.model = "umap.cortex.sketch",
  dims = 1:50,
  refdata = list(full_first_type = "first_type")
)
```
```{r rctd_results, fig.height=8, eval=FALSE}
DefaultAssay(object) <- "Spatial.008um"
object[[]][, "cortex_first_type"] <- "Unknown"
object$cortex_first_type[Cells(cortex)] <- cortex$full_first_type[Cells(cortex)]

p <- SpatialDimPlot(object, images="slice1.008um", group.by = "cortex_first_type", label=T, repel=T, label.size = 2) 
p
```

## Spatial neighborhood identification with BuildNicheAssay

```{r build.niches}
DefaultAssay(object) <- "Spatial.008um"
neighbors <- 200
object <- BuildNicheAssay(object = object, fov = "slice1.008um", group.by = "cortex_first_type", niches.k = 20, neighbors.k = neighbors)
```
```{r niches.plot}
p <- SpatialDimPlot(object, group.by="niches", label=T, repel=T)
p
```

## Analysis

Labeling niches/Banksy clusters as layers
```{r celltype.plot, fig.height = 12}
# decide whether to use niches or Banksy clusters to define layers 
excitatory_neurons <- c("L6 CT CTX","L2 IT ENTl","L5-6 NP CTX","L4-5 IT CTX","L5 IT CTX","L6b CTX", "L2-3 IT ENTl", "L4 RSP-ACA", "L2-3 IT CTX", " L5 PT CTX", "L6 IT CTX", "L2-3 IT PPP", "L5-6 IT TPE-ENT", "L6b-CT ENT", "L3 IT ENT", "L2 IT ENTm", "L5 PPP", "L2-3 IT RHP", "L6 IT ENTl")

plot_cell_types <- function(data, label) {
  p <- ggplot(data, aes(x = get(label), y = n, fill = cortex_first_type)) +
    geom_bar(stat = "identity", position = "stack") +
    geom_text(aes(label = ifelse(n >= min_count_to_show_label, cortex_first_type, "")),
              position = position_stack(vjust = 0.5), size = 2) +
    xlab(label) +
    ylab("Number of Cells") +
    ggtitle(paste0("Distribution of Cell Types across ", label)) +
    theme_minimal()
}

cell_type_banksy_counts <- object[[]] %>%
  dplyr::filter(cortex_first_type %in% excitatory_neurons) %>%
  dplyr::count(cortex_first_type, banksy_cluster)

cell_type_niche_counts <- object[[]] %>%
  dplyr::filter(cortex_first_type %in% excitatory_neurons) %>%
  dplyr::count(cortex_first_type, niches)

min_count_to_show_label <- 50

p1 <- plot_cell_types(cell_type_banksy_counts, "banksy_cluster")
p2 <- plot_cell_types(cell_type_niche_counts, "niches")
p1/p2
```
```{r layer.label}
# label layers
excitatory_neurons_subset <- object[[]][object$cortex_first_type %in% excitatory_neurons, ]
contingency_table <- table(excitatory_neurons_subset$cortex_first_type, excitatory_neurons_subset$banksy_cluster)
cluster_types <- apply(contingency_table, 2, function(x) names(which.max(x)))
match <- as.data.frame(cluster_types[match(object$banksy_cluster, names(cluster_types))], row.names = rownames(object[[]]))
colnames(match) <- "layer"
object$layer <- match$layer
```
```{r prop.plot}
# create barplot to show proportions of cell types of interest
neurons <- c("Lamp5", "Sst", "Pvalb", "Sst Chodl", "Sncg", "Vip", "Oligo", "Astro")
neuron_props <- reshape2::melt(prop.table(table(object$cortex_first_type, object$layer)[neurons,], margin = 1))
ggplot(neuron_props, aes(x = Var1, y = value, fill = Var2)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(x = "Cell type", y = "Proportion", fill = "Layer") +
  theme_classic()
```

