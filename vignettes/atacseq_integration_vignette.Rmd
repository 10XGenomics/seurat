---
title: "PBMC scATAC-seq Vignette"
output:
  html_document:
    theme: united
    df_print: kable
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---

```{r markdown.setup, include=FALSE}
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(
  tidy = TRUE,
  fig.width = 12,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE
)
```

**Update February 2020: we now have developed a separate package, [Signac](https://satijalab.org/signac/), for the analysis and integration of scATAC-seq data.
See the Signac website for up-to-date [vignettes](https://satijalab.org/signac/articles/pbmc_vignette.html) and documentation for analysing scATAC-seq data.**

In this vignette, we demonstrate our new data transfer method in the context of scATAC-seq to

* Classify cells measured with scATAC-seq based on clustering results from scRNA-seq
* Co-embed scATAC-seq and scRNA-seq data

For this example we'll be working with the 10X PBMC datasets that contain ~10K cells for both scRNA-seq and scATAC-seq. You can download those here: [scATAC-seq](http://cf.10xgenomics.com/samples/cell-atac/1.0.1/atac_v1_pbmc_10k/atac_v1_pbmc_10k_filtered_peak_bc_matrix.h5), [scATAC-seq metadata](http://cf.10xgenomics.com/samples/cell-atac/1.0.1/atac_v1_pbmc_10k/atac_v1_pbmc_10k_singlecell.csv),  [scRNA-seq](http://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5)

Overall our integration procedure consists of the following steps:

1. Estimate RNA-seq levels from ATAC-seq (quantify gene expression 'activity' from ATAC-seq reads)
2. Learn the internal structure of the ATAC-seq data on its own (accomplished using LSI)
3. Identify 'anchors' between the ATAC-seq and RNA-seq datasets
4. Transfer data between datasets (either transfer labels for classification, or impute RNA levels in the ATAC-seq data to enable co-embedding)

# Gene activity quantification

First, we load in the provided peak matrix and collapse the peak matrix to a "gene activity matrix". Here, we make the simplifying assumption that a gene's activity can be quantified by simply summing all counts within the gene body + 2kb upstream but our method is compatible with any method that returns a gene by cell matrix (e.g. [Cicero](https://cole-trapnell-lab.github.io/cicero-release/)). 

```{r gene.activity.matrix}
library(Seurat)
library(ggplot2)
library(patchwork)
peaks <- Read10X_h5("../data/atac_v1_pbmc_10k_filtered_peak_bc_matrix.h5")
# create a gene activity matrix from the peak matrix and GTF, using chromosomes 1:22, X, and Y. Peaks that fall within gene bodies, or 2kb upstream of a gene, are considered
activity.matrix <- CreateGeneActivityMatrix(peak.matrix = peaks, annotation.file = "../data/Homo_sapiens.GRCh37.82.gtf", seq.levels = c(1:22,"X","Y"), upstream = 2000,  verbose = TRUE)
```

# Object setup

Next, we'll set up the `Seurat` object and store both the original peak counts in the "ATAC" `Assay` and the gene activity matrix in the "RNA" `Assay`. As a QC step, we also filter out all cells here with fewer than 5K total counts in the scATAC-seq data, though you may need to modify this threshold for your experiment. 

```{r setup.object}
pbmc.atac <- CreateSeuratObject(counts = peaks, assay = 'ATAC', project = '10x_ATAC')
pbmc.atac[['ACTIVITY']] <- CreateAssayObject(counts = activity.matrix)
meta <- read.table("../data/atac_v1_pbmc_10k_singlecell.csv", sep = ",", header = TRUE, row.names = 1, stringsAsFactors = FALSE)
meta <- meta[colnames(pbmc.atac), ]
pbmc.atac <- AddMetaData(pbmc.atac, metadata = meta)
pbmc.atac <- subset(pbmc.atac, subset = nCount_ATAC > 5000)
pbmc.atac$tech <- "atac"
```

# Data preprocessing

Here, we process the gene activity matrix in order to find anchors between cells in the scATAC-seq dataset and the scRNA-seq dataset.

```{r process.am}
DefaultAssay(pbmc.atac) <- 'ACTIVITY'
pbmc.atac <- FindVariableFeatures(pbmc.atac)
pbmc.atac <- NormalizeData(pbmc.atac)
pbmc.atac <- ScaleData(pbmc.atac)
```

We also process the peak matrix. Here we perform latent semantic indexing to reduce the dimensionality of the scATAC-seq data. This procedure learns an 'internal' structure for the scRNA-seq data, and is important when determining the appropriate weights for the anchors when transferring information. We utilize Latent Semantic Indexing (LSI) to learn the structure of ATAC-seq data, as proposed in [Cusanovich et al, Science 2015](https://science.sciencemag.org/content/348/6237/910/tab-pdf) and implemented in the `RunLSI` function. LSI is implemented here by performing computing the term frequency-inverse document frequency (TF-IDF) followed by SVD.

We use all peaks that have at least 100 reads across all cells, and reduce dimensionality to 50. The parameters chosen here are inspired by previous scATAC-seq analyses, and we do not typically change them, but you can do so.

```{r process.pm}
DefaultAssay(pbmc.atac) <- "ATAC"
VariableFeatures(pbmc.atac) <- names(which(Matrix::rowSums(pbmc.atac) > 100))
pbmc.atac <- RunLSI(pbmc.atac, n = 50, scale.max = NULL)
pbmc.atac <- RunUMAP(pbmc.atac, reduction = "lsi", dims = 1:50)
```

We have previously pre-processed and clustered a scRNA-seq dataset using the standard workflow in Seurat, and provide the object [here](https://www.dropbox.com/s/3f3p5nxrn5b3y4y/pbmc_10k_v3.rds?dl=1). You can see that we can identify standard clusters of myeloid and lymphoid PBMCs.

```{r loading.rds}
pbmc.rna <- readRDS("../data/pbmc_10k_v3.rds")
pbmc.rna$tech <- "rna"
```

```{r init.viz}
p1 <- DimPlot(pbmc.atac, reduction = "umap") + NoLegend() + ggtitle("scATAC-seq")
p2 <- DimPlot(pbmc.rna, group.by = "celltype", label = TRUE, repel = TRUE) + NoLegend() + ggtitle("scRNA-seq")
p1 + p2
```

Now, we can identify anchors between the scATAC-seq dataset and the scRNA-seq dataset and use these anchors to transfer the celltype labels we learned from the 10K scRNA-seq data to the scATAC-seq cells. 

```{r transfer.anchors}
transfer.anchors <- FindTransferAnchors(
  reference = pbmc.rna,
  query = pbmc.atac,
  features = VariableFeatures(object = pbmc.rna),
  reference.assay = 'RNA',
  query.assay = 'ACTIVITY',
  reduction = 'cca'
)
```

To transfer the cluster ids, we provide a vector of previously annotated cell type labels for the RNA to the `refdata` parameter. The output will contain a matrix with predictions and confidence scores for each ATAC-seq cell.

```{r transfer.data}
celltype.predictions <- TransferData(
  anchorset = transfer.anchors,
  refdata = pbmc.rna$celltype,
  weight.reduction = pbmc.atac[['lsi']]
)
pbmc.atac <- AddMetaData(pbmc.atac, metadata = celltype.predictions)
```

<details>
  <summary>**Why do you choose different (non-default) values for reduction and weight.reduction?**</summary>
  
  In `FindTransferAnchors`, we typically project the PCA structure from the reference onto the query when transferring between scRNA-seq datasets. However, when transferring across modalities we find that CCA better captures the shared feature correlation structure and therefore set `reduction = 'cca'` here. Additionally, by default in `TransferData` we use the same projected PCA structure to compute the weights of the local neighborhood of anchors that influence each cell's prediction. In the case of scRNA-seq to scATAC-seq transfer, we use the low dimensional space learned by computing an LSI on the ATAC-seq data to compute these weights as this better captures the "internal" structure of the ATAC-seq data.
  
</details>
\  

We can then examine the distribution of prediction scores and optionally filter out those cells with low scores. Here, we find that over 95% of the cells receive a score of 0.5 or greater.

```{r filter.scores}
hist(pbmc.atac$prediction.score.max)
abline(v = 0.5, col = "red")
table(pbmc.atac$prediction.score.max > 0.5)
```

We can then view the predicted cell types on a UMAP representation of the scATAC-seq data and find that the transferred labels are highly consistent with the UMAP structure. 

```{r atac.viz}
pbmc.atac.filtered <- subset(pbmc.atac, subset = prediction.score.max > 0.5)
pbmc.atac.filtered$predicted.id <- factor(pbmc.atac.filtered$predicted.id, levels = levels(pbmc.rna)) # to make the colors match
p1 <- DimPlot(pbmc.atac.filtered, group.by = "predicted.id", label = TRUE, repel = TRUE) + ggtitle("scATAC-seq cells") + NoLegend() + scale_colour_hue(drop = FALSE)
p2 <- DimPlot(pbmc.rna, group.by = "celltype", label = TRUE, repel = TRUE) + ggtitle("scRNA-seq cells") + NoLegend()
p1 + p2
```

After transferring cell type labels, you can then perform downstream analyses on a cell type specific level. For example, you could find sets of enhancers that are specific for certain cell types and look for motif enrichment. While not all of these types of downstream analyses are directly supported in Seurat, stay tuned for updates in this space. 

# Co-embedding

Finally, to visualize all the cells together, we can co-embed the scRNA-seq and scATAC-seq cells in the same low dimensional space. Here, we use the same anchors used earlier to transfer cell type labels to impute RNA-seq values for the scATAC-seq cells. We then merge the measured and imputed scRNA-seq data and run a standard UMAP analysis to visualize all the cells together. Note that this step is for visualization purposes only and is not a necessary part of the data transfer analysis. 

```{r coembed}
# note that we restrict the imputation to variable genes from scRNA-seq, but could impute the full transcriptome if we wanted to
genes.use <- VariableFeatures(pbmc.rna)
refdata <- GetAssayData(
  pbmc.rna,
  assay = 'RNA',
  slot = 'data'
)[genes.use, ]

# refdata (input) contains a scRNA-seq expression matrix for the scRNA-seq cells.
# imputation (output) will contain an imputed scRNA-seq matrix for each of the ATAC cells
imputation <- TransferData(
  anchorset = transfer.anchors,
  refdata = refdata,
  weight.reduction = pbmc.atac[['lsi']]
)

# this line adds the imputed data matrix to the pbmc.atac object
pbmc.atac[["RNA"]] <- imputation
coembed <- merge(
  x = pbmc.rna,
  y = pbmc.atac
)

# Finally, we run PCA and UMAP on this combined object, to visualize the co-embedding of both datasets
coembed <- ScaleData(coembed, features = genes.use, do.scale = FALSE)
coembed <- RunPCA(coembed, features = genes.use, verbose = FALSE)
coembed <- RunUMAP(coembed, dims = 1:30)
coembed$celltype <- ifelse(!is.na(coembed$celltype), coembed$celltype, coembed$predicted.id)
```

Here we plot all cells colored by either their assigned cell type (from the 10K dataset) or their predicted cell type from the data transfer procedure. 
```{r viz}
p1 <- DimPlot(coembed, group.by = "tech")
p2 <- DimPlot(coembed, group.by = "celltype", label = TRUE, repel = TRUE)
p1 + p2
```

```{r include=FALSE}
p1 <- p1 + xlab("UMAP 1") + ylab("UMAP 2") + 
  theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + 
  guides(colour = guide_legend(override.aes = list(size = 10)))
ggsave(filename = "../output/images/atacseq_integration_umap.png", height = 7, width = 12, plot = p1)
```

<details>
  <summary>**How can I further investigate unmatched groups of cells that only appear in one assay?**</summary>

Upon inspection of the UMAP embeddings, there appeared several groups of cells that appeared to be present only in a single assay. First, the platelet cells appeared only in the scRNA-seq data. These cells are thought to be undergoing biogenesis from megakaryocytes to platelets and therefore either completely lack nuclear material or their chromatin state is uncoupled from their transcriptome. As a result, we would not expect these to align in this analysis. 

```{r platelets}
DimPlot(coembed, split.by = "tech", group.by = "celltype", label = TRUE, repel = TRUE) + NoLegend()
```

Additionally, there appeared to be a population next to the B cell progenitors that is composed entirely of scATAC-seq cells and is not integrated well with the scRNA-seq cells. Further examination of the metadata for these cells revealed a high number of reads mapping to blacklisted regions (as provided by the 10x Genomics QC metrics). This suggests that these barcodes could represent dead or dying cells, ambient DNA, or another technical artifact not represented in the scRNA-seq dataset. 

```{r blacklist}
coembed$blacklist_region_fragments[is.na(coembed$blacklist_region_fragments)] <- 0
FeaturePlot(coembed, features = "blacklist_region_fragments", max.cutoff = 500)
```

</details>
\  

<details>
  <summary>**How can I evaluate the success of cross-modality integration?**</summary>
  
   There are several lines of evidence here that give us confidence in this analysis.
   
   1. Overall, the prediction scores are high which suggest a high degree of confidence in our cell type assignments.
   2. We observe good agreement between the scATAC-seq only dimensional reduction (UMAP plot above) and the transferred labels.
   3. The co-embedding based on the same set of anchors gives good mixing between the two modalities.
   4. When we collapse the ATAC-seq reads on a per-cluster basis into "pseudo bulk" profiles, we observe good concordance with the chromatin patterns observed in bulk data ([Supplementary Figure S3](https://doi.org/10.1016/j.cell.2019.05.031))
   
   Additionally, we have performed a similar analysis, transferring cell type labels from scRNA-seq to scATAC-seq data in the context of the mouse brain and have observed good performance based on similar reasoning to the points above ( [Figure 3](https://doi.org/10.1016/j.cell.2019.05.031)). These analyses make the assumption that there is generally a positive correlation between chromatin accessibility and gene expression. In cases such as developing systems, where accessibility may not be a good indicator of transcription, the method demonstrated here may not be able to form good anchors and the resulting integration across these specific modalities may be of limited value. 
  
</details>
\  

```{r save.times, include = FALSE}
write.csv(x = t(as.data.frame(all_times)), file = "../output/timings/atacseq_integration_vignette_times.csv")
```

